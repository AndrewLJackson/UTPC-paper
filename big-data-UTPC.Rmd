---
title: "Run UTPC on the big datasets"
output: html_notebook
---


```{r setup}
library(tidyverse)
library(magrittr)
library(readxl)
library(patchwork)
library(plotly) # for interactive plots
library(ggforce) # for multi page facet plots
library(kableExtra)
```




## Import the data


```{r}

big_dd <- read.csv("data/thermal_performance_datasets.csv") %>%
  rename(type = `id`) %>%
  select(-citation)

```

Loop over the datasets and fit a quadratic as a test for concave downwards criterion.

```{r}

# a function to fit a quadratic and test for concave down. 
concaveDown <- function(x){
  
  m1 <- lm(trait_value ~ temperature + I(temperature^2), data = x)
  
  out <- ifelse(summary(m1)$coefficients[3,4] <= 0.2 & 
           summary(m1)$coefficients[3,1] < 0, 
         TRUE, FALSE)
  
  return(x %>% mutate(concaveDown = out))
  
}

big_dd %<>% 
  split(.$type) %>% 
  map(~possibly(concaveDown, otherwise = 'error here')(.x)) %>%
  bind_rows() %>% 
  filter(concaveDown)

```





### Fit our own parameters using UTPC method

We optimise on the least squares of the rescaled data to the universal thermal performance curve using the L-BFSG-U approach to bound the parameters. 

```{r}

# define our fitness function which is the sum of squares of 
# the predicted - observed
tpc_fit <- function(x, pf, ta){
  
  # extract the parameters
  yopt  <- x[1] # the value of y at the optimum
  Topt  <- x[2] # the optimal temperature
  Delta <- x[3] # the difference between Tc-Topt
  Tc    <- Topt + Delta # calculate Tc
  
  # sum of squares
  sum(((yopt * exp( (ta - Topt) / Delta) * (1 - (ta - Topt)/Delta)) - pf) ^ 2)
  
  
}

# a function to find sensible initial values for the optimiser
get_inits <- function(x){
  
  # initialise the initial parameter value vector
  inits <- c(NA, NA, NA)
  
  # find the largest performance
  idx_max_y <- which.max(x$pf)
  
  # the largest y value is a good guess for yopt
  inits[1] <- x$pf[idx_max_y]
  
  # the corresponding temperature is a good guess for Topt
  inits[2] <- x$ta[idx_max_y]
  
  # use the largest T value as a simple guess for Delta
  inits[3] <-tail(x$ta[is.finite(x$ta)],1) - inits[2]
  
  # return the initial values
  return(inits)
}


# a wrapper function to do the fit and return a data.frame
# The object x coming in is a data.frame of the same structure
# as the full dataset. The output is a tibble of the same structure
# with columns appended for estimates of the universal TPC with 
# prefix "u_"
do_tpc_fit <- function(x){
  
  # call the optimiser
  fit <- optim(get_inits(x), 
               tpc_fit,
               pf = x$pf, 
               ta = x$ta,
               method = "L-BFGS-B",
               lower = c(0.2, 10^-3, 1), 
               upper = c(10, 150, Inf))
  
  # return a tibble (data.frame)
  return(x %<>% mutate(u_yopt  = fit$par[1],
                       u_Topt  = fit$par[2],
                       u_Delta = fit$par[3],
                       u_Tc    = fit$par[2] + fit$par[3], 
                       SS = fit$value)
         )

  
}


# this function takes a fitted UTPC model and scales the data to the 
# UTPC. Returns a data.frame the same as the original data.frame
# with new columns for 
# scaled performance pf_utpc 
# and scaled temperature ta_utpc
data2utpc <- function(dd){
  dd %<>% mutate(pf_utpc = pf / u_yopt,
                ta_utpc = (ta - u_Topt) / u_Delta
                )
  return(dd)
}

# This function scales the UTPC curve to the original data based on 
# the fitted UTPC model. Returns a new data.frame with n values of 
# the UTPC function evaluated and rescaled to the data provied in dd.
# Performance can be adjusted according by subtracting the value given in 
# p_adj, and would typically be used to allow for negative performance values
# in the data. 
utpc2data <- function(dd, y_adj = 0, n = 100){
  UTPC <- data.frame(x = seq(-4, 1, length.out = n)) %>%
  mutate(y = (1-x)*exp(x)) %>%
  mutate(ta = (x * dd$u_Delta[1]) + dd$u_Topt[1],
         pf = (y * dd$u_yopt[1] - y_adj),
         type = dd$type[1],
         pf_max = dd$pf_max[1]
)
  return(UTPC)
}
```

### Map over all the data

```{r}


# rescale performance data to be numbers closer to 1
big_dd <- big_dd %>% group_by(type) %>% 
  mutate(ta = temperature,
         pf_max = max(trait_value),
         pf = trait_value / pf_max) %>%
  ungroup()


# split the data on "code" variable and map our optimiser over all
# the possibly() function acts as an error catcher, and then rebind it 
# into a single tibble again on completion.
big_dd %<>% 
  split(.$type) %>% 
  map(~possibly(do_tpc_fit, otherwise = 'error here')(.x)) %>%
  bind_rows()

## save this object to file
save(big_dd, 
     file = "data/combined_dat_params.rda", 
     compress = "xz")

## write to file
# write.csv(combined_dat_params, 
#           file = "data_for_JF.csv", 
#           row.names = FALSE)

# rescale the data onto the UTPC scale
dd_utpc <- data2utpc(big_dd)


```


## Visualise the UTPC on all data

Before visualisng the data, we need to recognise and identify that a relatively small proportion of the datasets do not fit well. This is on account of some of them having a small temperature range that does not approach the optimum even close, and others have zero performance values interspersed along the temperature range. Some of them also fit with very high pf_max values which on the UTPC scale should be very close to 1: we exclude fits that are more than 2.

Some of the model fits end up close to boundaries of our set limits on Topt, and we can start by excluding those. In the full dataset there are `r length(unique(big_dd$type))` experiments reported. We create a new column that flags the dataset as "problematic" if it satifies our criteria. There is also one dataset `40031` that produces an estimated $T_c > 200$ which is clearly inappropriate.  

```{r}
dd_utpc %<>% mutate(problematic = case_when(
  u_Topt <= 0.1 | u_Topt >99 | u_yopt >= 2 ~ TRUE,
  type == 40031 ~ TRUE, 
  .default = FALSE
))

# set all to false to ignore this filter
# dd_utpc %<>% mutate(problematic = FALSE)

```

This flags `r nrow(unique(dd_utpc[dd_utpc$problematic, "type"]))` experiments as potential problem fits, and we exclude these going forward.


Summarise the data for the non-problematic fits. 

```{r}

dd_utpc %>% group_by(phylum, problematic) %>% summarise(n_type = length(unique(type))) %>%
  pivot_wider(names_from = problematic, values_from = n_type) %>% 
  ungroup() %>% 
  kableExtra::kable()

```


separate panels by phylum



```{r, fig.height=12}

gg1 <- ggplot(data = dd_utpc %>% filter(!problematic), 
              mapping = aes(x = ta_utpc, 
                                       y = pf_utpc)) + 
  geom_point() + 
  facet_wrap(vars(phylum), 
             scales = "free_x") +
  ylim(-0.1,5) +
  xlim(-6,1.1) + 
  geom_function(fun = function(x) pmax((1-x) * exp(x), 0),
                col = "red", xlim = c(-6, 1))
  # ylim(0, 10)

print(gg1)
```


## Plot the UTPCs excluding data and models that do not fit well

NB plot only curves which have esimtated $pf_{max}$ on the UTPC scale less than 2. We would expect them all to be very close to 1.

```{r}
g_focus_utpc <- ggplot(data = dd_utpc %>% 
                         filter(!problematic) %>%
                      mutate(type = factor(type)), 
                  mapping = aes(x = ta_utpc, y = pf_utpc)) + 
  geom_point(size = 1, alpha = 0.2) + 
  scale_color_viridis_d(guide="none") +
  # scale_color_viridis_d() + 
  geom_function(fun = function(x) pmax((1-x) * exp(x), 0),
                col = "white", linewidth = 1, xlim = c(-6, 1)) + 
  ylim(-0.5, 5) +
  xlim(-6, 1.1) + 
  theme_classic() + 
  xlab(expression(italic("(T"["trial"]*" - T"["opt"]*") / (T"["c"]*" - T"["opt"]*")"))) +
  ylab( expression("Pf / Pf"["max"]*"") )
  

print(g_focus_utpc)
```

As an ancilliary figure, we can explore the relationship between the estimated Tc and T_opt.

```{r}

# group by type and summarise to extract only one value per fitted
# dataset. 

gg_Topt_Tc <- ggplot(data = dd_utpc %>% filter(!problematic) %>%
                       group_by(type) %>% 
                       summarise(u_Topt = u_Topt[1], 
                                 u_Tc = u_Tc[1]) %>% 
                       ungroup(), 
                     mapping = aes(x = u_Topt, y = u_Tc)) + 
  geom_point(alpha = 0.5) + 
  # ylim(0, 100) +
  geom_smooth(method = "lm", color = "red") + 
  geom_abline(slope = 1, intercept = 0, color = "blue")

print(gg_Topt_Tc)

```

Find and plot the dataset that generates the Tc estimate > 200.

```{r}

ggplot(data = dd_utpc %>% filter(u_Tc >200), 
       mapping = aes(x = ta, y = pf, color = factor(type))) + 
  geom_point()

```


## Focus on the problematic fits


We could plot them but there are too many even for a series of multipanel plots. Here we just plot the first page of them.

```{r, fig.height=12}

# tmp <- data.frame(u_Delta = 7, u_Topt = 42, u_yopt = 0.00073, 
#                   type = -999)
# 
# tmp_utpc = utpc2data(tmp)

dd_prob_utpcs <- dd_utpc %>% filter(problematic) %>% split(.$type) %>% 
  map(utpc2data) %>% bind_rows()


g_raw_prbs <- ggplot(data = dd_utpc %>% 
                       filter(problematic) %>%
                        mutate(type = factor(type)), 
                  mapping = aes(x = ta, y = pf / pf_max)) + 
  geom_point() + 
  geom_line() + 
  geom_line(data = dd_utpc %>% 
                       filter(problematic) %>%
              mutate(type = factor(type)), linetype = 2) +
  # facet_wrap(vars(type), scales = "free")
  facet_wrap_paginate(vars(type), scales = "free",
                      page = 1) + 
  geom_line(data = dd_prob_utpcs %>% mutate(type = factor(type)),
            mapping = aes(x = ta, y = pf / pf_max), 
            color = "red")
  # scale_color_viridis_d(guide="none")
  # geom_line(data = tmp_utpc, color = "black")
  


print(g_raw_prbs)

```

We can also print a table summarising these problematic datasets along with some of the fitted parameters, but again there are too many in this instance. For many of them, the $pf_{max}$ fitted parameter is maxed out at the upper limit of the model fit (10).

```{r, eval = TRUE}

dd_utpc %>% 
  filter(problematic) %>% 
  group_by(type) %>%
  summarise(phylum = phylum[1],
            taxon = taxon[1],
            u_Topt = u_Topt[1], 
            u_yopt = u_yopt[1],
            u_Tc = u_Tc[1],
            pf_max = pf_max[1], 
            ) %>%
  kable(digits = 2)

```

